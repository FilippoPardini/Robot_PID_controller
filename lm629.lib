/****************************************************************************
* ATxmega library for the LM629 - Version 1.0                               *
* © Copyright 2012,2013 Filippo Pardini - filippo@robotica.eng.br           *
*                                                                           *
* This program is free software: you can redistribute it and/or modify it   *
* under the terms of the GNU Lesser General Public License as published by  *
* the Free Software Foundation, either version 3 of the License, or any     *
* later version.                                                            *
*                                                                           *
* This program is distributed in the hope that it will be useful,           *
* but WITHOUT ANY WARRANTY; without even the implied warranty of            *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              *
* GNU Lesser General Public License for more details.                       *
*                                                                           *
* You should have received a copy of the GNU Lesser General Public License  *
* along with this program. If not, see <http://www.gnu.org/licenses/>.      *
****************************************************************************/

/*

This version was developed for the ATxmega128A1 using the CodeVisionAVR compiler.
This librarie contain all the macro functions needed to interface two LM629N-6
with an ATxmega128A1 microcontroller for the purpose of controlling the movements
of a robot with differential steering. The solution uses a PID feedback loop to
achieve the control of the robot movements in the position or velocity mode using
the sign/magnitude and quadrature incremental encoder interfaces of the LM629.

	http://www.ti.com/lit/ds/symlink/lm629.pdf
    http://www.ti.com/lit/an/snva025c/snva025c.pdf
    http://www.ti.com/lit/an/snoa184c/snoa184c.pdf
    http://www.ti.com/lit/an/snoa170b/snoa170b.pdf
    http://www.mil.ufl.edu/projects/gnuman/spec_sheets/LM629_interface_Guide.pdf
    http://www.cs.columbia.edu/~allen/F11/NOTES/icckinematics.pdf
    http://www.atmel.com/Images/doc8067.pdf
    http://www.atmel.com/Images/doc8077.pdf
    http://en.wikipedia.org/wiki/Rotary_encoder
    http://en.wikipedia.org/wiki/PID_controller
________________________________________________________________________________________________________________________

In this version I chose to use the NXP PCA9554 (8 bit I²C bus I/O port)

    http://www.nxp.com/documents/data_sheet/PCA9554_9554A.pdf

for the communication port with the two LM629. This has three reasons:
    - uses only 2 pins (TWI - SDA,SLC) and not 8 pins
    - These same pins are used for other TWI functions (ex: LCD)
    - It automatically acts as a logical level converter (Xmega(3.3V) <=> LM629(5V))

For this reason there is the library twipca.h/twipca.lib .

In addition to the port above, we need mor 7 pins to control the two LM629:

    2 for selection (CS - one for each)
    2 for reset (RST - one for each)
    1 for read (RD - one for both)
    1 for write (WR - one for both)
    1 for type command or data (PS - one for both)

These pins also need logical level convertion that may be obtained via a TXB0108

    http://www.ti.com/lit/ds/sces643e/sces643e.pdf

Since these entries in the LM629 are "active-low", they need "pull-up" resistors.
Care must be taken in choosing the resistors value. Due to the restrictions of the
TXB0108 they must be at least 50K (100K works OK).

For the TWI pins (SDA,SLC) also we need logical level conversion, but because we
need 1.8K "pull-up" resistors on the 3.3 side, we can't use the TXB0108. For the
prototype I used a "BOB-08745" from Sparkfun:

    https://www.sparkfun.com/products/8745

For messages and debug I use the I2C(TWI) LCD03 from Devantech:

    http://www.robot-electronics.co.uk/htm/Lcd03tech.htm

For this reason there is also the library twilcd.h/twilcd.lib .

For electromechanical control I used two LMD18200, two old 61.46.052 Buehler motors
and two old H5S-250-I from USDigital.

    http://www.ti.com/lit/ds/snvs091e/snvs091e.pdf
    http://www.usdigital.com/assets/datasheets/H5_datasheet.pdf?k=634913185143995582

In this version I chose not to use the LM629 interrupt system. So, all the interrupts
are detected via polling of the "Status Byte".

For the mechanical system with the motors used, the tuning of the PID filter resulted in:

Ds = 2
Kp = 10
Ki = 0
Kd = 1000
Ii = 1000

These parameters are not generic, they depend on the mechanical system and motors.
Therefore, for each case, a tuning need to be done according to "Tuning the PID Filter" in:

    http://www.ti.com/lit/an/snva025c/snva025c.pdf

To help in tuning there is the function "Tuning_PID" and to help in debug there is the
functions "debug_parameter" and "debug_SB".
________________________________________________________________________________________________________________________

LM629 COMMANDS:

    Name    Code      Data     Meaning
                      Bytes
    RESET   0x00/00    0       Reset LM629
    DFH     0x02/02    0       Define Home
    SIP     0x03/03    0       Set Index Position (não usado)
    LPEI    0x1B/27    2       0x0000 a 0x7FFF Load Position Error for Interrupt
    LPES    0x1A/26    2       0x0000 a 0x7FFF Load Position Error for Stopping
    SBPA    0x20/32    4       0xC0000000 a 0x3FFFFFFF Set Breakpoint Absolute
    SBPR    0x21/33    4       See Manual SBPR
    MSKI    0x1C/28    2       See Manual Mask Interrupts
    RSTI    0x1D/29    2       See Manual Reset Interrupts
    LFIL    0x1E/30    2 a 10  See Manual Load Filter Parameters
    UDF     0x04/04    0       Update Filter
    LTRJ    0x1F/31    2 a 14  See Manual Load Trajectory Parameters
    STT     0x01/01    0       Start Motion Control
    RDSTAT             1       Read Status Byte
    RDSIGS  0x0C/12    2       Read Signals Register
    RDIP    0x09/09    4       0xC0000000 a 0x3FFFFFFF Read Index Position (not used)
    RDDP    0x08/08    4       0xC0000000 a 0x3FFFFFFF Read Desired Position (not used)
    RDRP    0x0A/10    4       0xC0000000 a 0x3FFFFFFF Read Real Position (not used)
    RDDV    0x07/07    4       0xC0000000 a 0x3FFFFFFF Read Desired Velocity (not used)
    RDRV    0x0B/11    2       0xC000 a 0x3FFF Read Real Velocity (not used)
    RDSUM   0x0D/13    2       See Manual Read Integration Term (not used)

************************************************************************************************************************
************** The first three commands must be - Initialize_SysLM629, Initialize_Drive and Wakeup_Robot ***************
************************************************************************************************************************
*/

#include <io.h>
#include <iobits.h>
#include <stdio.h>
#include <stdbool.h>
#include <delay.h>
#include <twix.h>
#include <twilcd.h>
#include <twipca.h>
#include <portas.h>
#include <varias.h>
#include <stdlib.h>
#include <math.h>

//************************** MACROS ************************************************************************************

#define ad_eternum while(1)
#define Bits(n) (unsigned char)1 << n
#define True 1
#define False 0
#define High 1
#define Low 0
#define Input 0x00
#define Output 0xFF
#define Forward 1
#define Backward 0
#define LMD 1               //LM629_1 - right wheel
#define LME 2               //LM629_2 - left wheel
#define LMB 3               //Both (LM629_1 e LM629_2)

#define RESET 0x00
#define DFH 0x02
#define LPEI 0x1B
#define LPES 0x1A
#define SBPA 0x20
#define SBPR 0x21
#define MSKI 0x1C
#define RSTI 0x1D
#define LFIL 0x1E
#define UDF 0x04
#define LTRJ 0x1F
#define STT 0x01
#define RDSIGS 0x0C

//Calculates the time interval in milliseconds between the present instant and an earlier instant t.
//t was defined previously by the *tempo variable. Ex: unsigned long int t0; ...... t0 = *tempo
#define delta_time(t) (unsigned long int)(*tempo - (unsigned long int)t)

//************************** VARIABLES *********************************************************************************

unsigned long int *tempo;   //Pointer to relogio
float Ts;                   //Sample period
float A;	                //Acceleration in cm/seg**2 - Default = Amax
float V;  	                //Velocity in cm/seg - Default = Vmax
bool DIR;  	                //Velocity mode movement direction - 1 => Forward; 0 => Backward
unsigned long int TT;       //Time interval between STT commands

//************************** ROBOT PARAMETERS **************************************************************************

//These parameters are motors, wheels and encoders dependent. They must be revised in each case.

float Amax;                 //Maximum acceleration in Cm/seg**2
float Vmax;                 //Maximum velocity in Cm/seg
float Croda;                //Wheel circumference in Cm
float Deixo;                //Distance between wheels em Cm
unsigned int Cr;            //Encoder counts per revolution. Channels A and B

//LMD
float dMt;                  //multiplier - (wheel revolution)/(encoder revolution) relationship
unsigned char dDs;          //Derivative-term sampling interval
unsigned int dKKp;          //PID filter Kp coefficient
unsigned int dKKi;          //PID filter Ki coefficient
unsigned int dKKd;          //PID filter Kd coefficient
unsigned int dKIi;          //PID filter Ii coefficient

//LME
float eMt;                  //multiplier - (wheel revolution)/(encoder revolution) relationship
unsigned char eDs;          //Derivative-term sampling interval
unsigned int eKKp;          //PID filter Kp coefficient
unsigned int eKKi;          //PID filter Ki coefficient
unsigned int eKKd;          //PID filter Kd coefficient
unsigned int eKIi;          //PID filter Ii coefficient

//************************** LM629 COMMUNICATION ************************************************************************

unsigned int parametro[8];      //LM629 parameter vector

#define word(n) parametro[n-1]  //word(1) a word(8) => parametro[0] a parametro[7]

//Displays the LM629 command parameters in hexadecimal
//td - display time in seconds
//n - parameters number without the control-word
//tipo - 'W' => indicates that the parameters are words (integer 2 bytes)
//'D' => indicates that the parameters are double-words (long integer 4 bytes)
//parm - parameter vector
//If n > 3, will be displayed 4 lines during td seconds, and so on
void debug_parameter(unsigned int td,unsigned char n,unsigned char tipo,unsigned int *parm);

//Displays the Status Byte of the two LM629
void debug_SB(unsigned char i,bool para);

//************************** PORTS AND PINS ****************************************************************************

unsigned char prta;                 //PCA9554 TWI address
unsigned char CS_LMD[3] = "  ";	    //LM629-1 selection pin (right wheel)
unsigned char CS_LME[3] = "  ";	    //LM629-2 selection pin (left wheel)
unsigned char RST_LMD[3] = "  ";    //LM629-1 reset pin
unsigned char RST_LME[3] = "  ";    //LM629-2 reset pin
unsigned char RD[3] = "  ";         //LM629 read pin
unsigned char WR[3] = "  ";         //LM629 write pin
unsigned char PS[3] = "  ";         //LM629 type pin: command (0) or data (1)

//************************************* LM629 FUNCTIONS ****************************************************************

bool Initialize_SysLM629(unsigned long int *rel,float cts,unsigned char prt,unsigned char *cslmd,
                         unsigned char *cslme,unsigned char *rstlmd,unsigned char *rstlme,unsigned char *prd,
                         unsigned char *pwr,unsigned char *pps,float pamax,float pvmax,float pcroda,float pdeixo,
                         unsigned int pcr)
{
    //Initializes the LM629 - basic parameters
    //rel - pointer to tempo variable (interrupt TCD1)
    //cts - sampling period Ts
    //prtc - TWI-PCA9554 address  Ex: 0x40
    //cslmd - pin for selecting LM629-1 (right wheel)
    //cslme - pin for selecting LM629-2 (left wheel)
    //rstlmd - pin for resetting LM629-1
    //rstlme - pin for resetting LM629-2
    //prd - pin for sending status and data to the port
    //pwr - pin for sending from port to command and data
    //pps - pin for selecting the port mode: commands (0) or data (1)
    //pamax - maximum acceleration em Cm/seg**2
    //pvmax - maximum speed Cm/seg
    //pcroda - wheel circumference Cm
    //pdeixo - wheel to wheel distance Cm
    //pcr - encoder counts per revolution channels A and B
    //Example:
    //Initialize_SysLM629(&relogio,0.0004096,PTA,"B1","B2","B3","B4","B5","B6","B7",30.0,80.0,31.0,33.5,1000);

    tempo = rel;
    TT = *tempo;
    Ts = cts;
    prta = prt;
    copy_string(CS_LMD,cslmd);
    pin_OUTPUT(CS_LMD);
    putpin(CS_LMD,High);
    copy_string(CS_LME,cslme);
    pin_OUTPUT(CS_LME);
    putpin(CS_LME,High);
    copy_string(RST_LMD,rstlmd);
    pin_OUTPUT(RST_LMD);
    putpin(RST_LMD,High);
    copy_string(RST_LME,rstlme);
    pin_OUTPUT(RST_LME);
    putpin(RST_LME,High);
    copy_string(RD,prd);
    pin_OUTPUT(RD);
    putpin(RD,High);
    copy_string(WR,pwr);
    pin_OUTPUT(WR);
    putpin(WR,High);
    copy_string(PS,pps);
    pin_OUTPUT(PS);
    putpin(PS,High);

    Amax = pamax;
    A = Amax;
    Vmax = pvmax;
    V = Vmax;
    Croda = pcroda;
    Deixo = pdeixo;
    Cr = pcr;
}

//______________________________________________________________________________________________________________________

bool Initialize_Drive(unsigned char Lm,float multiplicador,unsigned char pds,unsigned int pkkp,
                      unsigned int pkki,unsigned int pkkd,unsigned int pkii)
{
    //Initializes the LM629 - PID parameters
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both
    //pds - Derivative-term sampling interval
    //pkkp - PID filter Kp coefficient
    //pkki - PID filter Ki coefficient
    //pkkd - PID filter Kd coefficient
    //pkii - PID filter Ii coefficient
    //Example:  Initialize_Drive(LMB,5.0,0,15,0,0,0);

    switch (Lm)
    {
        case LMD:
            dMt = multiplicador;
            dDs = pds;
            dKKp = pkkp;
            dKKi = pkki;
            dKKd = pkkd;
            dKIi = pkii;
            break;
        case LME:
            eMt = multiplicador;
            eDs = pds;
            eKKp = pkkp;
            eKKi = pkki;
            eKKd = pkkd;
            eKIi = pkii;
            break;
        case LMB:
            dMt = eMt = multiplicador;
            dDs = eDs = pds;
            dKKp = eKKp = pkkp;
            dKKi = eKKi = pkki;
            dKKd = eKKd = pkkd;
            dKIi = eKIi = pkii;
    }
}

//______________________________________________________________________________________________________________________

void Set_V(float Ve)
{
    //Defines the robot velocity before a trajectory command
    //Ve => Cm/seg

    if (Ve > Vmax) Ve = Vmax;
    else V = Ve;
}

//______________________________________________________________________________________________________________________

void Select_LM629(unsigned char Lm)
{
    //Selects the LM629
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both

    switch (Lm)
    {
        case LMD:
            putpin(CS_LME,High);
            putpin(CS_LMD,Low);
            break;
        case LME:
            putpin(CS_LMD,High);
            putpin(CS_LME,Low);
            break;
        case LMB:
            putpin(CS_LMD,Low);
            putpin(CS_LME,Low);
    }
}

//______________________________________________________________________________________________________________________

unsigned char RDSTAT(unsigned char Lm)
{
    //Returns the LM629 Status Byte
    //Lm = LMD => right wheel;Lm = LME => left wheel
    //Example:
    //X = RDSTAT(LMD) ...;

    unsigned char X;

    Select_LM629(Lm);           //Seleciona o LM629 solicitado, CS => 0
    Configure_Port(prta,Input); //Configura a porta como entrada
    putpin(PS,Low);             //PS => 0
    putpin(RD,Low);             //RD => 0
    delay_us(1);
    X = Get_Port(prta);         //Lê o byte que está na porta
    putpin(RD,High);            //RD => 1
    return X;
}

//______________________________________________________________________________________________________________________

unsigned long int AccCounts(unsigned char Lm,float Acel)
{
    //Acceleration in Counts/Sample**2
    //Lm = LMD => right wheel;Lm = LME => left wheel
    //Acel: Cm/seg**2

    switch (Lm)
    {
        case LMD:
            return (unsigned long int)(ceil((Acel / Croda * Ts * Ts * (float)(Cr) * dMt * (float)(65536))));
        case LME:
            return (unsigned long int)(ceil((Acel / Croda * Ts * Ts * (float)(Cr) * eMt * (float)(65536))));
    }
}

//______________________________________________________________________________________________________________________

unsigned long int VelCounts(unsigned char Lm,float Velo)
{
    //Velocity in Counts/Sample
    //Lm = LMD => right wheel;Lm = LME => left wheel
    //Velo: Cm/Seg

    switch (Lm)
    {
        case LMD:
            return (unsigned long int)(ceil((Velo / Croda * Ts * (float)(Cr) * dMt * (float)(65536))));
        case LME:
            return (unsigned long int)(ceil((Velo / Croda * Ts * (float)(Cr) * eMt * (float)(65536))));
    }
}

//______________________________________________________________________________________________________________________

signed long int PosCounts(unsigned char Lm,float Posi)
{
    //Distance in Counts
    //Lm = LMD => right wheel;Lm = LME => left wheel
    //Posi: Cm

    switch (Lm)
    {
        case LMD:
            return (signed long int)(ceil((Posi / Croda * dMt * (float)(Cr))));
        case LME:
            return (signed long int)(ceil((Posi / Croda * eMt * (float)(Cr))));
    }
}

//______________________________________________________________________________________________________________________

bool SB_Bit(unsigned char Lm,unsigned char byt)
{
    //Reads bit Byt of Status Byte
    //Lm = LMD => right wheel;Lm = LME => left wheel
    //byt: 0 a 7

    if ((RDSTAT(Lm) & Bits(byt)) == Bits(byt)) return True;
    return False;
}

//______________________________________________________________________________________________________________________

void Wait_BusyBit(unsigned char Lm)
{
    //Waits Status Byte bit 0 be 0
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both

    switch (Lm)
    {
        case LMD:
            while (SB_Bit(LMD,0));
            break;
        case LME:
            while (SB_Bit(LME,0));
            break;
        case LMB:
            while (SB_Bit(LMD,0));
            while (SB_Bit(LME,0));
    }
}

//______________________________________________________________________________________________________________________

bool Position_Error(void)
{
    //Detects position error in both LM629

    if (SB_Bit(LMD,5) | SB_Bit(LME,5)) return True;
    return False;
}

//______________________________________________________________________________________________________________________

bool Verify_Robot_Stopped(void)
{
    //Detects if robot is stopped

    if (SB_Bit(LMD,7) & SB_Bit(LME,7)) return True;
    return False;
}

//______________________________________________________________________________________________________________________

void Set_A(float Ac)
{
    //Defines the robot acceleration for a movement. The robot must be stopped. Remember that is not possible to change
    //acceleration during a movement.
    //Ac => Cm/seg/seg

    if (Verify_Robot_Stopped())
    {
        if (Ac > Amax) A = Amax;
        else A = Ac;
    }
}

//______________________________________________________________________________________________________________________

void Send_Byte(unsigned char Lm,unsigned char Valor,unsigned char Tipo)
{
    //Sends a command or data byte to the LM629 saying if it is to wait
    //Status Byte bit 0 be 0 after execution
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both
    //Valor - Byte to send
    //Tipo - 0 = command, 1 = first data byte, 2 = second data byte

    Configure_Port(prta,Output);
    Put_Port(prta,Valor);
    Select_LM629(Lm);
    putpin(PS,Tipo);
    putpin(WR,Low);
    delay_us(1);
    putpin(WR,High);
}

//______________________________________________________________________________________________________________________

unsigned char Receive_Byte(unsigned char Lm)
{
    //Receives a byte in the port
    //Lm = LMD => right wheel;Lm = LME => left wheel

    unsigned char X;

    Select_LM629(Lm);
    Configure_Port(prta,Input);
    putpin(PS,High);
    putpin(RD,Low);
    delay_us(1);
    X = Get_Port(prta);
    putpin(RD,High);
    return X;
}

//______________________________________________________________________________________________________________________

unsigned int Receive_Word(unsigned char Lm)
{
    //Receives 2 bytes (int) from LM629 => [MSB][LSB]
    //Lm = LMD => right wheel;Lm = LME => left wheel

    unsigned char b1,b2;

    b1 = Receive_Byte(Lm);
    b2 = Receive_Byte(Lm);
    Wait_BusyBit(Lm);

    return put_char_int(b1,b2);
}

//______________________________________________________________________________________________________________________

unsigned long int Receive_Doubleword(unsigned char Lm)
{
    //Receives 4 bytes (long int) from LM629 => [MSBH][LSBH][MSBL][LSBL]
    //Lm = LMD => right wheel;Lm = LME => left wheel

    unsigned char b1,b2,b3,b4;

    b1 = Receive_Byte(Lm);
    b2 = Receive_Byte(Lm);
    Wait_BusyBit(Lm);
    b3 = Receive_Byte(Lm);
    b4 = Receive_Byte(Lm);
    Wait_BusyBit(Lm);
    return put_char_long(b1,b2,b3,b4);
}

//______________________________________________________________________________________________________________________

void Send_Command(unsigned char Lm,unsigned char Cmnd,unsigned char Np)
{
    //Sends a command to the LM629 saying the parameters number (word)
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both
    //Cmnd - command code
    //Np - parameters number (words)

    unsigned char I;

    Wait_BusyBit(Lm);
    if (Cmnd == STT)
    {
        while (delta_time(TT) < 10);
        Send_Byte(Lm,Cmnd,0);
        Wait_BusyBit(Lm);
        TT = *tempo;
        return;
    }
    Send_Byte(Lm,Cmnd,0);
    Wait_BusyBit(Lm);
    if (Np == 0) return;
    for (I=1;I<=Np;I++)
    {
        Send_Byte(Lm,get_char_int(1,word(I)),1);
        Send_Byte(Lm,get_char_int(2,word(I)),1);
        Wait_BusyBit(Lm);
    }
}

//______________________________________________________________________________________________________________________

unsigned int Read_Signals_Register(unsigned char Lm)
{
    //Reads the Signal Register
    //Lm = LMD => right wheel;Lm = LME => left wheel

    Send_Command(Lm,RDSIGS,0);
    return Receive_Word(Lm);
}

//______________________________________________________________________________________________________________________

void Wait_Robot_OnTarget(void)
{
    //Waits the Signals Register On Target Flag of both LM629

    while (!SB_Bit(LMD,2));
    while (!SB_Bit(LME,2));
}

//______________________________________________________________________________________________________________________

void Start_Robot_Trajectory(bool wait)
{
    //Executes the robot trajectory waiting or not for the robot on target
    //wait - True => wait; False => do not wait

    Send_Command(LMB,STT,0);
    if (!wait) return;
    Wait_Robot_OnTarget();
}

//______________________________________________________________________________________________________________________

void Reset_Interrupts(unsigned char Lm,unsigned char mask)
{
    //Executes the RSTI command
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both
    //mask - resets the interrupts
    //If Bit1 ... Bit6 = 0, that interrupt will be resetted
    //Bit0 -
    //Bit1 - Command-Error Interrupt
    //Bit2 - Trajectory-Complete Interrupt
    //Bit3 - Index-Pulse Interrupt
    //Bit4 - Wrap-Around Interrupt
    //Bit5 - Position-Error Interrupt
    //Bit6 - Breakpoint Interrupt
    //Bit7 -

    word(1) = put_char_int(0,mask);
    Send_Command(Lm,RSTI,1);
}

//______________________________________________________________________________________________________________________

void Mask_Interrupts(unsigned char Lm,unsigned char mask)
{
    //Executes the MSKI command
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both
    //mask - mask the interrupts
    //If Bit1 ... Bit6: 0 disable and 1 enable that interrupt
    //Bit0 -
    //Bit1 - Command-Error Interrupt
    //Bit2 - Trajectory-Complete Interrupt
    //Bit3 - Index-Pulse Interrupt
    //Bit4 - Wrap-Around Interrupt
    //Bit5 - Position-Error Interrupt
    //Bit6 - Breakpoint Interrupt
    //Bit7 -

    word(1) = put_char_int(0,mask);
    Send_Command(Lm,MSKI,1);
}

//______________________________________________________________________________________________________________________

void Load_Position_Error_for_Interrupt(unsigned char Lm,unsigned int TresholdPosErr)
{
    //Executes LPEI command
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both
    //TresholdPosErr: treshold for position error detection in counts
    //The detection occurs when the absolute value of the position error exceeds TresholdPosErr

    word(1) = TresholdPosErr;
    Send_Command(Lm,LPEI,1);
}

//______________________________________________________________________________________________________________________

void Load_Position_Error_for_Stopping(unsigned char Lm,unsigned int TresholdPosErr)
{
    //Executes LPES command
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both
    //TresholdPosErr: treshold for position error detection in counts
    //The detection occurs when the absolute value of the position error exceeds TresholdPosErr

    word(1) = TresholdPosErr;
    Send_Command(Lm,LPES,1);
}

//______________________________________________________________________________________________________________________

void Set_Breakpoint_Absolute(unsigned char Lm,float Breakpoint)
{
    //Executes SBPA command
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both
    //Breakpoint: Breakpoint for absolute position in centimeters
    //The Status Byte bit 6 is set when the position is reached

    signed long int aux;

    aux = PosCounts(Lm,Breakpoint);

    word(1) = get_int_long(1,aux);
    word(2) = get_int_long(2,aux);
    Send_Command(Lm,SBPA,2);
}

//______________________________________________________________________________________________________________________

void Set_Breakpoint_Relative(unsigned char Lm,float Breakpoint)
{
    //Executes SBPR command
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both
    //Breakpoint: Breakpoint for relative position in centimeters
    //The Status Byte bit 6 is set when the position is reached

    signed long int aux;

    aux = PosCounts(Lm,Breakpoint);

    word(1) = get_int_long(1,aux);
    word(2) = get_int_long(2,aux);
    Send_Command(Lm,SBPR,2);
}

//______________________________________________________________________________________________________________________

void Wait_Breakpoint(unsigned char Lm)
{
    //Waits the Status Byte breakpoint reached flag
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both

    switch (Lm)
    {
        case LMD:
            while (!SB_Bit(LMD,6));
            break;
        case LME:
            while (!SB_Bit(LME,6));
            break;
        case LMB:
            while (!SB_Bit(LMD,6));
            while (!SB_Bit(LME,6));
    }
}

//______________________________________________________________________________________________________________________

bool Is_Velocity_Mode(unsigned char Lm)
{
    //Verifies what is the mode: True - Velocity Mode; False - Position Mode
    //Lm = LMD => right wheel;Lm = LME => left wheel

    if ((get_char_int(1,Read_Signals_Register(Lm)) & Bits(3)) == Bits(3)) return True;
    return False;
}

//______________________________________________________________________________________________________________________

void Define_Home(unsigned char Lm)
{
    //Defines the present position as the absolute position 0
    //Lm = LMD => right wheel;Lm = LME => left wheel

    Send_Command(Lm,DFH,0);
}

//______________________________________________________________________________________________________________________

void Update_Filter (unsigned char Lm,unsigned char coef)
{
    //Executes the LFIL command. It is important to remember that the
    //PID filter tuning must be done to achieve a critical system dumping
    //looking for an optimized performance.
    //See "Tuning the PID Filter" at http://www.ti.com/lit/an/snva025c/snva025c.pdf
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both
    //coef FCW LSB
    //bit 0 => loads KIi
    //bit 1 => loads KIi
    //bit 2 => loads KIi
    //bit 3 => loads KIi
    //bits 4 a 7 => 0

    unsigned char Np;

    switch (Lm)
    {
        case LMD:
            word(1) = put_char_int(dDs,coef);
            Np = 1;
            if ((coef & Bits(3)) == Bits(3)) word(++Np) =  dKKp;
            if ((coef & Bits(2)) == Bits(2)) word(++Np) =  dKKi;
            if ((coef & Bits(1)) == Bits(1)) word(++Np) =  dKKd;
            if ((coef & Bits(0)) == Bits(0)) word(++Np) =  dKIi;
            Send_Command(LMD,LFIL,Np);
            break;
        case LME:
            word(1) = put_char_int(eDs,coef);
            Np = 1;
            if ((coef & Bits(3)) == Bits(3)) word(++Np) =  eKKp;
            if ((coef & Bits(2)) == Bits(2)) word(++Np) =  eKKi;
            if ((coef & Bits(1)) == Bits(1)) word(++Np) =  eKKd;
            if ((coef & Bits(0)) == Bits(0)) word(++Np) =  eKIi;
            Send_Command(LME,LFIL,Np);
            break;
        case LMB:
            word(1) = put_char_int(dDs,coef);
            Np = 1;
            if ((coef & Bits(3)) == Bits(3)) word(++Np) =  dKKp;
            if ((coef & Bits(2)) == Bits(2)) word(++Np) =  dKKi;
            if ((coef & Bits(1)) == Bits(1)) word(++Np) =  dKKd;
            if ((coef & Bits(0)) == Bits(0)) word(++Np) =  dKIi;
            Send_Command(LMD,LFIL,Np);
            word(1) = put_char_int(eDs,coef);
            Np = 1;
            if ((coef & Bits(3)) == Bits(3)) word(++Np) =  eKKp;
            if ((coef & Bits(2)) == Bits(2)) word(++Np) =  eKKi;
            if ((coef & Bits(1)) == Bits(1)) word(++Np) =  eKKd;
            if ((coef & Bits(0)) == Bits(0)) word(++Np) =  eKIi;
            Send_Command(LME,LFIL,Np);
    }
    Send_Command(Lm,UDF,0);
}

//______________________________________________________________________________________________________________________

void Load_Trajectory_Parameters (unsigned char Lm,bool FDir,bool MVel,bool CAcc,bool AccR,bool CVel,bool VelR,
                                 bool CPos,bool PosR,unsigned long int Acc,unsigned long int Vel,signed long int Pos)
{
    //Executes the LTRJ command that loads the trajectory parameters
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both
    //FDir: direction (only for velocity mode)
    //MVel: velocity mode
    //CAcc: loads acceleration
    //AccR: the acceleration is relative
    //CVel: loads velocity
    //VelR: the velocity is relative
    //CPos: loads position
    //PosR: the position is relative
    //Acc: acceleration in counts/sample**2
    //Vel: velocity in counts/sample
    //Pos: position in counts

    unsigned char Np;
    unsigned char TCW_MSB,TCW_LSB;


    TCW_MSB = 0x00;
    TCW_MSB |= FDir << 4;
    TCW_MSB |= MVel << 3;

    TCW_LSB = 0x00;
    TCW_LSB |= CAcc << 5;
    TCW_LSB |= AccR << 4;
    TCW_LSB |= CVel << 3;
    TCW_LSB |= VelR << 2;
    TCW_LSB |= CPos << 1;
    TCW_LSB |= PosR;

    word(1) = put_char_int(TCW_MSB,TCW_LSB);

    Np = 1;
    if ((TCW_LSB & Bits(5)) == Bits(5))
    {
        word(++Np) =  get_int_long(1,Acc);
        word(++Np) =  get_int_long(2,Acc);
    }
    if ((TCW_LSB & Bits(3)) == Bits(3))
    {
        word(++Np) =  get_int_long(1,Vel);
        word(++Np) =  get_int_long(2,Vel);
    }
    if ((TCW_LSB & Bits(1)) == Bits(1))
    {
        word(++Np) =  get_int_long(1,Pos);
        word(++Np) =  get_int_long(2,Pos);
    }

    //debug_parameter(10,3,'D',parametro);

    switch (Lm)
    {
        case LMD:
            Send_Command(LMD,LTRJ,Np);
            break;
        case LME:
            Send_Command(LME,LTRJ,Np);
    }
}

//______________________________________________________________________________________________________________________

void Stop_Motion(unsigned char Lm,unsigned char Tipo)
{
    //Stops the movement
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both
    //Tipo: 10 smoothly, 9 abruptly, 8 motor off

    word(1) = (unsigned int)1 << Tipo;

    //debug_parameter(10,0,'W',parametro);

    switch (Lm)
    {
        case LMD:
            Send_Command(LMD,LTRJ,1);
            break;
        case LME:
            Send_Command(LME,LTRJ,1);
            break;
        case LMB:
            Send_Command(LMD,LTRJ,1);
            Send_Command(LME,LTRJ,1);
    }
    Send_Command(Lm,STT,0);
}

//______________________________________________________________________________________________________________________

bool Hardware_Reset(unsigned char Lm,unsigned long int tout)
{
    //Executes the LM629 hardware initialization. Mandatory before LM629 use
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both
    //tout - time out in milliseconds (10ms multiple)

    unsigned char SB;
    unsigned long int t0;
    unsigned char aux[4];

    t0 = *tempo;
    switch (Lm)
    {
        case LMD:
            while(1)
            {
                while(1)
                {
                    putpin(RST_LMD,Low);
                    delay_us(5);
                    putpin(RST_LMD,High);
                    delay_ms(2);
                    SB = RDSTAT(LMD);
                    if ((SB == 0xC4) || (SB == 0x84)) break;
                    if (delta_time(t0) < tout);
                    else
                    {
                        if (delta_time(t0) < tout);
                        else return False;
                    }
                }
                Mask_Interrupts(LMD,0x00);
                Reset_Interrupts(LMD,0x00);
                SB = RDSTAT(LMD);
                if ((SB == 0xC0) || (SB == 0x80)) break;
                if (delta_time(t0) < tout);
                else return False;
            }
            return True;
        case LME:
            while(1)
            {
                while(1)
                {
                    putpin(RST_LME,Low);
                    delay_us(5);
                    putpin(RST_LME,High);
                    delay_ms(2);
                    SB = RDSTAT(LME);
                    if ((SB == 0xC4) || (SB == 0x84)) break;
                    if (delta_time(t0) < tout);
                    else
                    {
                        if (delta_time(t0) < tout);
                        else return False;
                    }
                }
                Mask_Interrupts(LME,0x00);
                Reset_Interrupts(LME,0x00);
                SB = RDSTAT(LME);
                if ((SB == 0xC0) || (SB == 0x80)) break;
                if (delta_time(t0) < tout);
                else return False;
            }
               return True;
        case LMB:
            while(1)
            {
                while(1)
                {
                    putpin(RST_LMD,Low);
                    delay_us(5);
                    putpin(RST_LMD,High);
                    delay_ms(2);
                    SB = RDSTAT(LMD);
                    if ((SB == 0xC4) || (SB == 0x84)) break;
                    else
                    {
                        if (delta_time(t0) < tout);
                        else return False;
                    }
                }

                Mask_Interrupts(LMD,0x00);
                Reset_Interrupts(LMD,0x00);
                SB = RDSTAT(LMD);
                if ((SB == 0xC0) || (SB == 0x80)) break;
                if (delta_time(t0) < tout);
                else return False;
            }
            while(1)
            {
                while(1)
                {
                    putpin(RST_LME,Low);
                    delay_us(5);
                    putpin(RST_LME,High);
                    delay_ms(2);
                    SB = RDSTAT(LME);
                    if ((SB == 0xC4) || (SB == 0x84)) break;
                    if (delta_time(t0) < tout);
                    else
                    {
                        if (delta_time(t0) < tout);
                        else return False;
                    }
                }
                Mask_Interrupts(LME,0x00);
                Reset_Interrupts(LME,0x00);
                SB = RDSTAT(LME);
                if ((SB == 0xC0) || (SB == 0x80)) break;
                if (delta_time(t0) < tout);
                else return False;
            }
            return True;
    }
}

//______________________________________________________________________________________________________________________

void Software_Reset(unsigned char Lm)
{
    //Executes the LM629 software initialization. Can be used after the hardware initialization
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both

    Configure_Port(prta,Output);
    Put_Port(prta,RESET);
    Select_LM629(Lm);
    putpin(PS,Low);
    putpin(WR,Low);
    delay_us(1);
    putpin(WR,High);
    delay_ms(2);

    Mask_Interrupts(Lm,0x00);
    Reset_Interrupts(Lm,0x00);
}

//______________________________________________________________________________________________________________________

void Wait_Robot_Stop(void)
{
    //Waits the Status Byte motor off flag of both LM629

    while (!SB_Bit(LMD,7));
    while (!SB_Bit(LME,7));
}

//______________________________________________________________________________________________________________________

void Absolute_Position_Move(unsigned char Lm,float PAcc,float PVel,float PPos)
{
    //Prepares an absolute position movement
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both
    //PAcc: cm/(seg)**2
    //Pvel: cm/seg
    //PPos: cm

    switch (Lm)
    {
        case LMD:
            Load_Trajectory_Parameters(LMD,False,False,True,False,True,False,True,False,AccCounts(LMD,PAcc),
                                       VelCounts(LMD,PVel),PosCounts(LMD,PPos));
            break;
        case LME:
            Load_Trajectory_Parameters(LME,False,False,True,False,True,False,True,False,AccCounts(LME,PAcc),
                                       VelCounts(LME,PVel),PosCounts(LME,PPos));
            break;
        case LMB:
            Load_Trajectory_Parameters(LMD,False,False,True,False,True,False,True,False,AccCounts(LMD,PAcc),
                                       VelCounts(LMD,PVel),PosCounts(LMD,PPos));
            Load_Trajectory_Parameters(LME,False,False,True,False,True,False,True,False,AccCounts(LME,PAcc),
                                       VelCounts(LME,PVel),PosCounts(LME,PPos));
    }
}

//______________________________________________________________________________________________________________________

void Relative_Position_Move(unsigned char Lm,float PAcc,float PVel,float PPos)
{
    //Prepares a relative position movement
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both
    //PAcc: cm/(seg)**2
    //Pvel: cm/seg
    //PPos: cm

    switch (Lm)
    {
        case LMD:
            Load_Trajectory_Parameters(LMD,False,False,True,False,True,False,True,True,AccCounts(LMD,PAcc),
                                       VelCounts(LMD,PVel),PosCounts(LMD,PPos));
            break;
        case LME:
            Load_Trajectory_Parameters(LME,False,False,True,False,True,False,True,True,AccCounts(LME,PAcc),
                                       VelCounts(LME,PVel),PosCounts(LME,PPos));
            break;
        case LMB:
            Load_Trajectory_Parameters(LMD,False,False,True,False,True,False,True,True,AccCounts(LMD,PAcc),
                                       VelCounts(LMD,PVel),PosCounts(LMD,PPos));
            Load_Trajectory_Parameters(LME,False,False,True,False,True,False,True,True,AccCounts(LME,PAcc),
                                       VelCounts(LME,PVel),PosCounts(LME,PPos));
    }
}

//______________________________________________________________________________________________________________________

void Velocity_Mode_Move (unsigned char Lm,bool FDir,bool CAcc,bool AccR,bool CVel,bool VelR,
                        float PAcc,float PVel)
{
    //Prepares a velocity mode movement. The calling program must issue the necessary
    //SBPA, SBPR, STT and StopMotion commands
    //Lm = LMD => right wheel;Lm = LME => left wheel;Lm = LMB => both
    //FDir: direction (only for velocity mode)
    //CAcc: loads acceleration
    //AccR: the acceleration is relative
    //CVel: loads velocity
    //VelR: the velocity is relative
    //PAcc: acceleration in cm/seg**2
    //PVel: velocity in cm/seg

    switch (Lm)
    {
        case LMD:
            Load_Trajectory_Parameters(LMD,FDir,True,CAcc,AccR,CVel,VelR,False,False,AccCounts(LMD,PAcc),
                                       VelCounts(LMD,PVel),0);
            break;
        case LME:
            Load_Trajectory_Parameters(LME,FDir,True,CAcc,AccR,CVel,VelR,False,False,AccCounts(LME,PAcc),
                                       VelCounts(LME,PVel),0);
            break;
        case LMB:
            Load_Trajectory_Parameters(LMD,FDir,True,CAcc,AccR,CVel,VelR,False,False,AccCounts(LMD,PAcc),
                                       VelCounts(LMD,PVel),0);
            Load_Trajectory_Parameters(LME,FDir,True,CAcc,AccR,CVel,VelR,False,False,AccCounts(LME,PAcc),
                                       VelCounts(LME,PVel),0);
    }
}

//______________________________________________________________________________________________________________________

void Drive_Forward(float Ac,float Ve)
{
    //Stright forward robot move in velocity mode
    //Ac => acceleration in Cm/seg/seg; Ve => velocity in Cm/seg

    if (Ac > Amax) A = Amax;
    else A = Ac;
    if (Ve > Vmax) V = Vmax;
    else V = Ve;
    DIR = True;

    Reset_Interrupts(LMD,0x00);
    Reset_Interrupts(LME,0x00);
    Velocity_Mode_Move(LMD,True,True,False,True,False,Ac,Ve);
    Velocity_Mode_Move(LME,False,True,False,True,False,Ac,Ve);
    Start_Robot_Trajectory(False);
}

//______________________________________________________________________________________________________________________

void Drive_Backward(float Ac,float Ve)
{
    //Stright backward robot move in velocity mode
    //Ac => acceleration in Cm/seg/seg; Ve => velocity in Cm/seg

    if (Ac > Amax) A = Amax;
    else A = Ac;
    if (Ve > Vmax) V = Vmax;
    else V = Ve;
    DIR = False;

    Reset_Interrupts(LMD,0x00);
    Reset_Interrupts(LME,0x00);
    Velocity_Mode_Move(LMD,False,True,False,True,False,Ac,Ve);
    Velocity_Mode_Move(LME,True,True,False,True,False,Ac,Ve);
    Start_Robot_Trajectory(False);
}

//______________________________________________________________________________________________________________________

void Change_Current_Move_Velocity(float Velo)
{
    //Changes the robot velocity during a velocity mode movement
    //Velo - velocity in cm/seg

    if (Velo > Vmax) V = Vmax;
    else V = Velo;

    Velocity_Mode_Move(LMD,DIR,False,False,True,False,A,V);
    Velocity_Mode_Move(LME,!DIR,False,False,True,False,A,V);
    Start_Robot_Trajectory(False);
}

//______________________________________________________________________________________________________________________

void Default_Current_Move_Velocity(void)
{
    //Changes the robot velocity to default during a velocity mode movement

    V = Vmax;

    Velocity_Mode_Move(LMD,DIR,False,False,True,False,A,V);
    Velocity_Mode_Move(LME,!DIR,False,False,True,False,A,V);
    Start_Robot_Trajectory(False);
}

//______________________________________________________________________________________________________________________

void Turn_Left(float Giro)
{
    //The robot turns Giro degrees in place counterclockwise
    //Giro - angle in degrees

    Giro = Giro / 360.0 * 3.14 * Deixo;

    Relative_Position_Move(LMB,A,V,-Giro);
    Start_Robot_Trajectory(True);
}

//______________________________________________________________________________________________________________________

void Turn_Right(float Giro)
{
    //The robot turns Giro degrees in place clockwise
    //Giro - angle in degrees

    Giro = Giro / 360.0 * 3.14 * Deixo;

    Relative_Position_Move(LMB,A,V,Giro);
    Start_Robot_Trajectory(True);
}

//______________________________________________________________________________________________________________________

void Drive_Forward_Distance(float Dist)
{
    //Stright forward robot move in position mode by a distance
    //Dist - distance in cm

    Relative_Position_Move(LMD,A,V,Dist);
    Relative_Position_Move(LME,A,V,-Dist);
    Start_Robot_Trajectory(True);
}

//______________________________________________________________________________________________________________________

void Drive_Backward_Distance(float Dist)
{
    //Stright backward robot move in position mode by a distance
    //Dist - distance in cm

    Relative_Position_Move(LMD,A,V,-Dist);
    Relative_Position_Move(LME,A,V,Dist);
    Start_Robot_Trajectory(True);
}

//______________________________________________________________________________________________________________________

bool Wakeup_Robot(bool Cp)
{
    //Initializes the robot

    if (!Hardware_Reset(LMB,5000)) return False;
    Software_Reset(LMB);
    Update_Filter(LMB,0x0F);
    if (Cp)
    {
        Relative_Position_Move(LMB,2.0,10.0,3.14 * Deixo);
        Start_Robot_Trajectory(True);
    }
    return True;
}

//______________________________________________________________________________________________________________________

void Sleep_Robot(void)
{
    //Turns off the robot. Before, the robot executes a complete turn in place

    Stop_Motion(LMB,9);
    delay_ms(1000);

    Relative_Position_Move(LMB,2.0,10.0,-3.14 * Deixo);
    Start_Robot_Trajectory(True);
}

//______________________________________________________________________________________________________________________

void Slower(void)
{
    //Changes the robot velocity to half of the current velocity (velocity mode)

    V = V / 2.0;
    Velocity_Mode_Move(LMD,DIR,False,False,True,False,A,V);
    Velocity_Mode_Move(LME,!DIR,False,False,True,False,A,V);
    Start_Robot_Trajectory(False);
}

//______________________________________________________________________________________________________________________

void Faster(void)
{
    //Changes the robot velocity to double of the current velocity (velocity mode)

    V = 2.0 * V;
    if (V > Vmax) V = Vmax;
    Velocity_Mode_Move(LMD,DIR,False,False,True,False,A,V);
    Velocity_Mode_Move(LME,!DIR,False,False,True,False,A,V);
    Start_Robot_Trajectory(False);
}

//______________________________________________________________________________________________________________________

void Go_Right(float Raio)
{
    //Calculates the new velocity of one wheel for the robot to drive in a curved
    //trajectory to the right with Raio cm gyration radius
    //Raio: trajectory gyration radius in cm

    float VD;

    if (Raio >= Deixo)
    {
        VD = V * (2.0 * Raio - Deixo) / (2.0 * Raio + Deixo);
        Velocity_Mode_Move(LMD,DIR,False,False,True,False,A,VD);
        Velocity_Mode_Move(LME,!DIR,False,False,True,False,A,V);
    }
    else
    {
        VD = V / 2.0;
        Velocity_Mode_Move(LMD,!DIR,False,False,True,False,A,VD);
        Velocity_Mode_Move(LME,!DIR,False,False,True,False,A,VD);
    }
    Start_Robot_Trajectory(False);
}

//______________________________________________________________________________________________________________________

void Go_Left(float Raio)
{
    //Calculates the new velocity of one wheel for the robot to drive in a curved
    //trajectory to the left with Raio cm gyration radius
    //Raio: trajectory gyration radius in cm

    float VE;

    if (Raio >= Deixo)
    {
        VE = V * (2.0 * Raio - Deixo) / (2.0 * Raio + Deixo);
        Velocity_Mode_Move(LMD,DIR,False,False,True,False,A,V);
        Velocity_Mode_Move(LME,!DIR,False,False,True,False,A,VE);
    }
    else
    {
        VE = V / 2.0;
        Velocity_Mode_Move(LMD,DIR,False,False,True,False,A,VE);
        Velocity_Mode_Move(LME,!DIR,False,False,True,False,A,VE);
    }
    Start_Robot_Trajectory(False);
}

//______________________________________________________________________________________________________________________

void Go_Stright(void)
{
    //The robot drives stright

    Velocity_Mode_Move(LMD,DIR,False,False,True,False,A,V);
    Velocity_Mode_Move(LME,!DIR,False,False,True,False,A,V);
    Start_Robot_Trajectory(False);
}

//______________________________________________________________________________________________________________________

void debug_parameter(unsigned int td,unsigned char n,unsigned char tipo,unsigned int *parm)
{
    //Displays the LM629 command parameters in hexadecimal
    //td - display time in seconds
    //n - parameters number without the control-word
    //tipo - 'W' => indicates that the parameters are words (integer 2 bytes)
    //'D' => indicates that the parameters are double-words (long integer 4 bytes)
    //parm - parameter vector
    //If n > 3, will be displayed 4 lines during td seconds, and so on

    unsigned char i,j,k,aux[21];

    sprintf(aux,"%04X",parm[0]);
    display(1,1,0,aux,0);
    j = 1;
    switch (tipo)
    {
        case 'W':
            for (i=1;i<=n;i++)
            {
                k = 0;
                j++;
                if (j > 4)
                {
                    delay_ms(td * 1000);
                    j = 1;
                    k = 1;
                }
                sprintf(aux,"%04X",parm[i]);
                display(k,j,0,aux,0);
            }
            break;
        case 'D':
            for (i=1;i<2*n;i+=2)
            {
                k = 0;
                j++;
                if (j > 4)
                {
                    delay_ms(td * 1000);
                    j = 1;
                    k = 1;
                }
                sprintf(aux,"%04X%04X",parm[i],parm[i+1]);
                display(k,j,0,aux,0);
            }
            break;
    }
    while(1);
}

//______________________________________________________________________________________________________________________

void debug_SB(unsigned char i,bool para)
{
    //Displays the Status Byte of the two LM629

    unsigned char SB1,SB2,aux[21];

    SB1 = RDSTAT(LMD);
    SB2 = RDSTAT(LME);

    sprintf(aux,"LMDSB=%02X LMESB=%02X",SB1,SB2);
    display(0,i,0,aux,0);
    if (!para) return;
    while(1);
}

//**********************************************************************************************************************

